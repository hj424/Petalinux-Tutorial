# state, next_state: registers
@s.combinational # one cycle delay!
def update_states():
  state.in_.value = next_state.out
@s.tick # 0 cycle delay
def undate_states():
  state = next_state # pointer
@s.tick # 2-cycle delay
def update_states():
  state.in_.next = next_state.out
  
# in combinational logic
# the coding sequence does matter!!
@s.combinational # one cycle delay!
def stall_states():
  stall = stall_A and stall_B and stall_C (1)
  # update stall_A
  # update stall_B
  # update stall_C
  
def stall_states():
  # update stall_A
  # update stall_B
  # update stall_C
  stall = stall_A and stall_B and stall_C (2)
# Get different circuit for (1) and (2)

# py.test
--tb=style            traceback print mode (auto/long/short/line/native/no).
py.test test/SparsePERTL_test.py --tb=short
